## Basic introduction to competitive programming

Competitive programming is a niche branch of programming that tests your algorithmic and implementation skills and allows you to have a lot of fun at the same tme as you play a game, submitting solutions to problems and getting points for the same.

As you've covered CS101 you have some basic idea of simple algorithms. That idea suffices to solve begginer problems on all sites. I would recommend to use Codeforces and Codechef as they contain problems of all levels with solutions.

This [article] (https://medium.com/techatucla/introduction-to-competitive-programming-3dca32e5f9a0) elaborates what I just said.

Regarding which language to use, it is recommended to use C++ as C++ contains implementations of various algorithms like sorting etc in it which makes it faster for you to solve problems. Check [this] (https://www.topcoder.com/community/competitive-programming/tutorials/power-up-c-with-the-standard-template-library-part-1/) for more information.

Firstly we will begin with Complexity Theory. You can have multiple algorithms that solve a problem, you however want one that is fast enough to solve the question given the limits. If your algorithm is slow you will get TLE (time limit exceeded).

Start with [this link] (https://www.hackerearth.com/practice/basic-programming/complexity-analysis/time-and-space-complexity/tutorial/). In a nutshell your algorithm will O(f(n)) if it takes roughly f(n) steps (or iterations) to finish. If your time limit is 1s you can afford atmost 10^8 operations per second. Or f(n) can be atmax 10^8 for every second.
Refer to [this](https://www.geeksforgeeks.org/knowing-the-complexity-in-competitive-programming/) and [this] (https://drive.google.com/file/d/0B-W-TWxgtybGd3dFUzg1OHNsM2M/view?usp=drive_open) for more information.

With that set, let's solve some basic problems that don't require anything other than logic. We call these problems 'ad-hoc'. I'll be giving you problems on codeforces so sign up on codeforces first. And then solve these questions!

1. [1294 A] (https://codeforces.com/contest/1294/problem/A)
2. [1288 A] (https://codeforces.com/contest/1288/problem/A)
3. [1339 A] (https://codeforces.com/contest/1339/problem/A)

This should give you an idea regarding how these judges work and how to solve basic problems. If you get stuck at any point of time click on Tutorial in the bottom right corner and you will get hints and solutions.

I hope you remember merge sort. Sorting can be used to simplifiy a lot of problems. Always use the built in C++ sort function as it makes life easier for CP. 
You can [check] (https://www.geeksforgeeks.org/know-sorting-algorithm-set-1-sorting-weapons-used-programming-languages/) this link to know more about sorting algrithms, this is useful for knowledge of algorithms and if you ever want to sit for an interview it's probably essential to know about them. But for questions you do not need to implement it yourself.
Try these questions:
1. [Smart Phone] (https://www.codechef.com/ZCOPRAC/problems/ZCO14003/)
[Hints] (https://www.commonlounge.com/discussion/262748517419452a8465547f58d0a7dc)
2. [1339 B] (https://codeforces.com/problemset/problem/1339/B)
3. [1334 B] (https://codeforces.com/problemset/problem/1334/B)

Now let us move on. Remember Binary Search? That simple algorithm has many applications with some being extremely tough. Let us start with a recap.

[Hackerearth] (https://www.hackerearth.com/practice/algorithms/searching/binary-search/tutorial/)
You can solve the problems given here for basics, they have editorials as well. Do a few of these. 
These are relatively harder and you may not be able to do them. Try for some time and then check the tutorial if you can't get them. This will give you an idea regarding the different ways you can apply binary search:
1. [1336 (Div 1) B] (https://codeforces.com/problemset/problem/1336/B)
2. [CodeJam Round 1B B] (https://codingcompetitions.withgoogle.com/codejam/round/000000000019fef2/00000000002d5b63): This is a tough problem that came in a contest yesterday. But the only thing you need to know to solve it is binary search! It is also an interactive problem, where you ask the system questions to determine the solution!. Such problems appear from time to time so you can try this out, the first two subtasks are relatively simpler. If you have a hard time with the third subtask check out the analysis section for the solution.

The above two problems are to give you a taste of how difficult questions can be set up. Don't get disheartened if you can't solve them, it requires practice.
